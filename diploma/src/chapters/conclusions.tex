\chapter{Conclusions}
\label{chapter:conclusions}

In this chapter we conclude our description on this project. In the first section \labelindexref{Summary}{sec:summary} we'll do a summary of how and what we managed to prove in this paper.

In the second section, \labelindexref{Further development}{sec:further-developments} we will discuss what could be developed next, starting from our work described in the \labelindexref{Implementation}{chapter:implementation} chapter.

\section{Summary}
\label{sec:summary}

In the first section of the opening chapter of this thesis, we pointed out the main goals that we wanted to achieve. Also we mentioned and that the project aimed to demonstrate if it is possible to have auto-exploration and auto-generation in a back-end agnostic front-end application. Based on these ideas we will present what we managed to achieve at the end of the development period.

\begin{itemize}
	\item Set up a back-end that features Django data models that are used for exposing data in a RESTful way.
	\item Set up a REST API and model schema in a single place (server-side) using Django Tastypie framework.
	\item Set up a consistent looking UI that is able to auto-explore a given resource and auto-generate generic forms.
	\item Customizing the generic forms for the user to be able to edit/delete or add them with minimal client-side work.
	\item Laid down the base for a scalable user interface trough styling frameworks like Bootstrap and Flexbox.
\end{itemize}

In conclusion, even though we had some challenges like incompatibilities between certain versions of the back-end frameworks we used, minor design bugs when learning the new React technology or code optimization in the end we managed to successfully accomplish all our objectives.

\section{Further developments}
\label{sec:further-developments}

The purpose of the project was to demonstrate that it is possible to build a front-end that is agnostic of it's back-end. Thus the relations between the data models we constructed were mostly \textbf{one-to-many} in the case of an \texttt{author} and his related \texttt{posts}. While this helps us to prove our point and have our front-end explore trough the post resource, the author that is assigned to it, we can encounter more complex cases in real life that.

The next step in our implementation would be integrating \textbf{many-to-many} relations between the data entities. A concrete example in our implementation would be having multiple authors assigned to multiple posts and being able to edit the authors assigned to a post accordingly.

Even if the work can be still improved by adding new relationship models or new generic type components we could pack the front-end application to work as a generic framework and later open source it to the community for further improvements.